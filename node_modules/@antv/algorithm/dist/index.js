(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.algorithm = {}));
}(this, (function (exports) { 'use strict';

  var adjMatrix = function adjMatrix(graphData, directed) {
    var nodes = graphData.nodes,
        edges = graphData.edges;
    var matrix = []; // map node with index in data.nodes

    var nodeMap = {};

    if (!nodes) {
      throw new Error('invalid nodes data!');
    }

    if (nodes) {
      nodes.forEach(function (node, i) {
        nodeMap[node.id] = i;
        var row = [];
        matrix.push(row);
      });
    }

    if (edges) {
      edges.forEach(function (edge) {
        var source = edge.source,
            target = edge.target;
        var sIndex = nodeMap[source];
        var tIndex = nodeMap[target];
        matrix[sIndex][tIndex] = 1;

        if (!directed) {
          matrix[tIndex][sIndex] = 1;
        }
      });
    }

    return matrix;
  };

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;

    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;

        var F = function () {};

        return {
          s: F,
          n: function () {
            if (i >= o.length) return {
              done: true
            };
            return {
              done: false,
              value: o[i++]
            };
          },
          e: function (e) {
            throw e;
          },
          f: F
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var normalCompletion = true,
        didErr = false,
        err;
    return {
      s: function () {
        it = o[Symbol.iterator]();
      },
      n: function () {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function (e) {
        didErr = true;
        err = e;
      },
      f: function () {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }

  var defaultComparator = function defaultComparator(a, b) {
    if (a === b) {
      return true;
    }

    return false;
  };
  /**
   * 链表中单个元素节点
   */


  var LinkedListNode = /*#__PURE__*/function () {
    function LinkedListNode(value) {
      var next = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      _classCallCheck(this, LinkedListNode);

      this.value = value;
      this.next = next;
    }

    _createClass(LinkedListNode, [{
      key: "toString",
      value: function toString(callback) {
        return callback ? callback(this.value) : "".concat(this.value);
      }
    }]);

    return LinkedListNode;
  }();

  var LinkedList = /*#__PURE__*/function () {
    function LinkedList() {
      var comparator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultComparator;

      _classCallCheck(this, LinkedList);

      this.head = null;
      this.tail = null;
      this.compare = comparator;
    }
    /**
     * 将指定元素添加到链表头部
     * @param value
     */


    _createClass(LinkedList, [{
      key: "prepend",
      value: function prepend(value) {
        // 在头部添加一个节点
        var newNode = new LinkedListNode(value, this.head);
        this.head = newNode;

        if (!this.tail) {
          this.tail = newNode;
        }

        return this;
      }
      /**
       * 将指定元素添加到链表中
       * @param value
       */

    }, {
      key: "append",
      value: function append(value) {
        var newNode = new LinkedListNode(value); // 如果不存在头节点，则将创建的新节点作为头节点

        if (!this.head) {
          this.head = newNode;
          this.tail = newNode;
          return this;
        } // 将新节点附加到链表末尾


        this.tail.next = newNode;
        this.tail = newNode;
        return this;
      }
      /**
       * 删除指定元素
       * @param value 要删除的元素
       */

    }, {
      key: "delete",
      value: function _delete(value) {
        if (!this.head) {
          return null;
        }

        var deleteNode = null; // 如果删除的是头部元素，则将next作为头元素

        while (this.head && this.compare(this.head.value, value)) {
          deleteNode = this.head;
          this.head = this.head.next;
        }

        var currentNode = this.head;

        if (currentNode !== null) {
          // 如果删除了节点以后，将next节点前移
          while (currentNode.next) {
            if (this.compare(currentNode.next.value, value)) {
              deleteNode = currentNode.next;
              currentNode.next = currentNode.next.next;
            } else {
              currentNode = currentNode.next;
            }
          }
        } // 检查尾部节点是否被删除


        if (this.compare(this.tail.value, value)) {
          this.tail = currentNode;
        }

        return deleteNode;
      }
      /**
       * 查找指定的元素
       * @param param0
       */

    }, {
      key: "find",
      value: function find(_ref) {
        var _ref$value = _ref.value,
            value = _ref$value === void 0 ? undefined : _ref$value,
            _ref$callback = _ref.callback,
            callback = _ref$callback === void 0 ? undefined : _ref$callback;

        if (!this.head) {
          return null;
        }

        var currentNode = this.head;

        while (currentNode) {
          // 如果指定了 callback，则按指定的 callback 查找
          if (callback && callback(currentNode.value)) {
            return currentNode;
          } // 如果指定了 value，则按 value 查找


          if (value !== undefined && this.compare(currentNode.value, value)) {
            return currentNode;
          }

          currentNode = currentNode.next;
        }

        return null;
      }
      /**
       * 删除尾部节点
       */

    }, {
      key: "deleteTail",
      value: function deleteTail() {
        var deletedTail = this.tail;

        if (this.head === this.tail) {
          // 链表中只有一个元素
          this.head = null;
          this.tail = null;
          return deletedTail;
        }

        var currentNode = this.head;

        while (currentNode.next) {
          if (!currentNode.next.next) {
            currentNode.next = null;
          } else {
            currentNode = currentNode.next;
          }
        }

        this.tail = currentNode;
        return deletedTail;
      }
      /**
       * 删除头部节点
       */

    }, {
      key: "deleteHead",
      value: function deleteHead() {
        if (!this.head) {
          return null;
        }

        var deletedHead = this.head;

        if (this.head.next) {
          this.head = this.head.next;
        } else {
          this.head = null;
          this.tail = null;
        }

        return deletedHead;
      }
      /**
       * 将一组元素转成链表中的节点
       * @param values 链表中的元素
       */

    }, {
      key: "fromArray",
      value: function fromArray(values) {
        var _this = this;

        values.forEach(function (value) {
          return _this.append(value);
        });
        return this;
      }
      /**
       * 将链表中的节点转成数组元素
       */

    }, {
      key: "toArray",
      value: function toArray() {
        var nodes = [];
        var currentNode = this.head;

        while (currentNode) {
          nodes.push(currentNode);
          currentNode = currentNode.next;
        }

        return nodes;
      }
      /**
       * 反转链表中的元素节点
       */

    }, {
      key: "reverse",
      value: function reverse() {
        var currentNode = this.head;
        var prevNode = null;
        var nextNode = null;

        while (currentNode) {
          // 存储下一个元素节点
          nextNode = currentNode.next; // 更改当前节点的下一个节点，以便将它连接到上一个节点上

          currentNode.next = prevNode; // 将 prevNode 和 currentNode 向前移动一步

          prevNode = currentNode;
          currentNode = nextNode;
        }

        this.tail = this.head;
        this.head = prevNode;
      }
    }, {
      key: "toString",
      value: function toString() {
        var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
        return this.toArray().map(function (node) {
          return node.toString(callback);
        }).toString();
      }
    }]);

    return LinkedList;
  }();

  var Queue = /*#__PURE__*/function () {
    function Queue() {
      _classCallCheck(this, Queue);

      this.linkedList = new LinkedList();
    }
    /**
     * 队列是否为空
     */


    _createClass(Queue, [{
      key: "isEmpty",
      value: function isEmpty() {
        return !this.linkedList.head;
      }
      /**
       * 读取队列头部的元素， 不删除队列中的元素
       */

    }, {
      key: "peek",
      value: function peek() {
        if (!this.linkedList.head) {
          return null;
        }

        return this.linkedList.head.value;
      }
      /**
       * 在队列的尾部新增一个元素
       * @param value
       */

    }, {
      key: "enqueue",
      value: function enqueue(value) {
        this.linkedList.append(value);
      }
      /**
       * 删除队列中的头部元素，如果队列为空，则返回 null
       */

    }, {
      key: "dequeue",
      value: function dequeue() {
        var removeHead = this.linkedList.deleteHead();
        return removeHead ? removeHead.value : null;
      }
    }, {
      key: "toString",
      value: function toString(callback) {
        return this.linkedList.toString(callback);
      }
    }]);

    return Queue;
  }();

  /**
   * 获取指定节点的所有邻居
   * @param nodeId 节点 ID
   * @param edges 图中的所有边数据
   * @param type 邻居类型
   */
  var getNeighbors = function getNeighbors(nodeId) {
    var edges = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var type = arguments.length > 2 ? arguments[2] : undefined;
    var currentEdges = edges.filter(function (edge) {
      return edge.source === nodeId || edge.target === nodeId;
    });

    if (type === 'target') {
      // 当前节点为 source，它所指向的目标节点
      var _neighhborsConverter = function _neighhborsConverter(edge) {
        return edge.source === nodeId;
      };

      return currentEdges.filter(_neighhborsConverter).map(function (edge) {
        return edge.target;
      });
    }

    if (type === 'source') {
      // 当前节点为 target，它所指向的源节点
      var _neighhborsConverter2 = function _neighhborsConverter2(edge) {
        return edge.target === nodeId;
      };

      return currentEdges.filter(_neighhborsConverter2).map(function (edge) {
        return edge.source;
      });
    } // 若未指定 type ，则返回所有邻居


    var neighhborsConverter = function neighhborsConverter(edge) {
      return edge.source === nodeId ? edge.target : edge.source;
    };

    return currentEdges.map(neighhborsConverter);
  };
  /**
   * 获取指定节点的出边
   * @param nodeId 节点 ID
   * @param edges 图中的所有边数据
   */

  var getOutEdgesNodeId = function getOutEdgesNodeId(nodeId, edges) {
    return edges.filter(function (edge) {
      return edge.source === nodeId;
    });
  };
  /**
   * 获取指定节点的边，包括出边和入边
   * @param nodeId 节点 ID
   * @param edges 图中的所有边数据
   */

  var getEdgesByNodeId = function getEdgesByNodeId(nodeId, edges) {
    return edges.filter(function (edge) {
      return edge.source === nodeId || edge.target === nodeId;
    });
  };
  /**
   * 生成唯一的 ID，规则是序号 + 时间戳
   * @param index 序号
   */

  var uniqueId = function uniqueId() {
    var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var random1 = "".concat(Math.random()).split('.')[1].substr(0, 5);
    var random2 = "".concat(Math.random()).split('.')[1].substr(0, 5);
    return "".concat(index, "-").concat(random1).concat(random2);
  };

  /**
   *
   * @param callbacks
   * allowTraversal: 确定 BFS 是否从顶点沿着边遍历到其邻居，默认情况下，同一个节点只能遍历一次
   * enterNode: 当 BFS 访问某个节点时调用
   * leaveNode: 当 BFS 访问访问结束某个节点时调用
   */

  function initCallbacks() {
    var callbacks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var initiatedCallback = callbacks;

    var stubCallback = function stubCallback() {};

    var allowTraversalCallback = function () {
      var seen = {};
      return function (_ref) {
        var next = _ref.next;
        var id = next;

        if (!seen[id]) {
          seen[id] = true;
          return true;
        }

        return false;
      };
    }();

    initiatedCallback.allowTraversal = callbacks.allowTraversal || allowTraversalCallback;
    initiatedCallback.enter = callbacks.enter || stubCallback;
    initiatedCallback.leave = callbacks.leave || stubCallback;
    return initiatedCallback;
  }
  /**
   * 广度优先遍历图
   * @param graph Graph 图实例
   * @param startNode 开始遍历的节点
   * @param originalCallbacks 回调
   */


  var breadthFirstSearch = function breadthFirstSearch(graphData, startNodeId, originalCallbacks) {
    var callbacks = initCallbacks(originalCallbacks);
    var nodeQueue = new Queue();
    var _graphData$edges = graphData.edges,
        edges = _graphData$edges === void 0 ? [] : _graphData$edges; // 初始化队列元素

    nodeQueue.enqueue(startNodeId);
    var previousNode = ''; // 遍历队列中的所有顶点

    var _loop = function _loop() {
      var currentNode = nodeQueue.dequeue();
      callbacks.enter({
        current: currentNode,
        previous: previousNode
      }); // 将所有邻居添加到队列中以便遍历

      getNeighbors(currentNode, edges, 'target').forEach(function (nextNode) {
        if (callbacks.allowTraversal({
          previous: previousNode,
          current: currentNode,
          next: nextNode
        })) {
          nodeQueue.enqueue(nextNode);
        }
      });
      callbacks.leave({
        current: currentNode,
        previous: previousNode
      }); // 下一次循环之前存储当前顶点

      previousNode = currentNode;
    };

    while (!nodeQueue.isEmpty()) {
      _loop();
    }
  };

  /**
   * Generate all connected components for an undirected graph
   * @param graph
   */

  var detectConnectedComponents = function detectConnectedComponents(graphData) {
    var _graphData$nodes = graphData.nodes,
        nodes = _graphData$nodes === void 0 ? [] : _graphData$nodes,
        _graphData$edges = graphData.edges,
        edges = _graphData$edges === void 0 ? [] : _graphData$edges;
    var allComponents = [];
    var visited = {};
    var nodeStack = [];

    var getComponent = function getComponent(node) {
      nodeStack.push(node);
      visited[node.id] = true;
      var neighbors = getNeighbors(node.id, edges);

      var _loop = function _loop(i) {
        var neighbor = neighbors[i];

        if (!visited[neighbor]) {
          var targetNode = nodes.filter(function (node) {
            return node.id === neighbor;
          });

          if (targetNode.length > 0) {
            getComponent(targetNode[0]);
          }
        }
      };

      for (var i = 0; i < neighbors.length; ++i) {
        _loop(i);
      }
    };

    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];

      if (!visited[node.id]) {
        // 对于无向图进行dfs遍历，每一次调用后都得到一个连通分量
        getComponent(node);
        var component = [];

        while (nodeStack.length > 0) {
          component.push(nodeStack.pop());
        }

        allComponents.push(component);
      }
    }

    return allComponents;
  };
  /**
   * Tarjan's Algorithm 复杂度  O(|V|+|E|)
   * For directed graph only
   * a directed graph is said to be strongly connected if "every vertex is reachable from every other vertex".
   * refer: http://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm
   * @param graph
   * @return a list of strongly connected components
   */

  var detectStrongConnectComponents = function detectStrongConnectComponents(graphData) {
    var _graphData$nodes2 = graphData.nodes,
        nodes = _graphData$nodes2 === void 0 ? [] : _graphData$nodes2,
        _graphData$edges2 = graphData.edges,
        edges = _graphData$edges2 === void 0 ? [] : _graphData$edges2;
    var nodeStack = [];
    var inStack = {}; // 辅助判断是否已经在stack中，减少查找开销

    var indices = {};
    var lowLink = {};
    var allComponents = [];
    var index = 0;

    var getComponent = function getComponent(node) {
      // Set the depth index for v to the smallest unused index
      indices[node.id] = index;
      lowLink[node.id] = index;
      index += 1;
      nodeStack.push(node);
      inStack[node.id] = true; // 考虑每个邻接点

      var neighbors = getNeighbors(node.id, edges, 'target').filter(function (n) {
        return nodes.map(function (node) {
          return node.id;
        }).indexOf(n) > -1;
      });

      var _loop2 = function _loop2(i) {
        var targetNodeID = neighbors[i];

        if (!indices[targetNodeID] && indices[targetNodeID] !== 0) {
          var targetNode = nodes.filter(function (node) {
            return node.id === targetNodeID;
          });

          if (targetNode.length > 0) {
            getComponent(targetNode[0]);
          } // tree edge


          lowLink[node.id] = Math.min(lowLink[node.id], lowLink[targetNodeID]);
        } else if (inStack[targetNodeID]) {
          // back edge, target node is in the current SCC
          lowLink[node.id] = Math.min(lowLink[node.id], indices[targetNodeID]);
        }
      };

      for (var i = 0; i < neighbors.length; i++) {
        _loop2(i);
      } // If node is a root node, generate an SCC


      if (lowLink[node.id] === indices[node.id]) {
        var component = [];

        while (nodeStack.length > 0) {
          var tmpNode = nodeStack.pop();
          inStack[tmpNode.id] = false;
          component.push(tmpNode);
          if (tmpNode === node) break;
        }

        if (component.length > 0) {
          allComponents.push(component);
        }
      }
    };

    var _iterator = _createForOfIteratorHelper(nodes),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var node = _step.value;

        if (!indices[node.id] && indices[node.id] !== 0) {
          getComponent(node);
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return allComponents;
  };
  function getConnectedComponents(graphData, directed) {
    if (directed) return detectStrongConnectComponents(graphData);
    return detectConnectedComponents(graphData);
  }

  var degree = function degree(graphData) {
    var degrees = {};
    var _graphData$nodes = graphData.nodes,
        nodes = _graphData$nodes === void 0 ? [] : _graphData$nodes,
        _graphData$edges = graphData.edges,
        edges = _graphData$edges === void 0 ? [] : _graphData$edges;
    nodes.forEach(function (node) {
      degrees[node.id] = {
        degree: 0,
        inDegree: 0,
        outDegree: 0
      };
    });
    edges.forEach(function (edge) {
      degrees[edge.source].degree++;
      degrees[edge.source].outDegree++;
      degrees[edge.target].degree++;
      degrees[edge.target].inDegree++;
    });
    return degrees;
  };
  /**
   * 获取指定节点的入度
   * @param graphData 图数据
   * @param nodeId 节点ID
   */

  var getInDegree = function getInDegree(graphData, nodeId) {
    var nodeDegree = degree(graphData);

    if (nodeDegree[nodeId]) {
      return degree(graphData)[nodeId].inDegree;
    }

    return 0;
  };
  /**
   * 获取指定节点的出度
   * @param graphData 图数据
   * @param nodeId 节点ID
   */

  var getOutDegree = function getOutDegree(graphData, nodeId) {
    var nodeDegree = degree(graphData);

    if (nodeDegree[nodeId]) {
      return degree(graphData)[nodeId].outDegree;
    }

    return 0;
  };

  function initCallbacks$1() {
    var callbacks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var initiatedCallback = callbacks;

    var stubCallback = function stubCallback() {};

    var allowTraversalCallback = function () {
      var seen = {};
      return function (_ref) {
        var next = _ref.next;

        if (!seen[next]) {
          seen[next] = true;
          return true;
        }

        return false;
      };
    }();

    initiatedCallback.allowTraversal = callbacks.allowTraversal || allowTraversalCallback;
    initiatedCallback.enter = callbacks.enter || stubCallback;
    initiatedCallback.leave = callbacks.leave || stubCallback;
    return initiatedCallback;
  }
  /**
   * @param {Graph} graph
   * @param {GraphNode} currentNode
   * @param {GraphNode} previousNode
   * @param {Callbacks} callbacks
   */


  function depthFirstSearchRecursive(graphData, currentNode, previousNode, callbacks) {
    callbacks.enter({
      current: currentNode,
      previous: previousNode
    });
    var _graphData$edges = graphData.edges,
        edges = _graphData$edges === void 0 ? [] : _graphData$edges;
    getNeighbors(currentNode, edges, 'target').forEach(function (nextNode) {
      if (callbacks.allowTraversal({
        previous: previousNode,
        current: currentNode,
        next: nextNode
      })) {
        depthFirstSearchRecursive(graphData, nextNode, currentNode, callbacks);
      }
    });
    callbacks.leave({
      current: currentNode,
      previous: previousNode
    });
  }
  /**
   * 深度优先遍历图
   * @param data GraphData 图数据
   * @param startNodeId 开始遍历的节点的 ID
   * @param originalCallbacks 回调
   */


  function depthFirstSearch(graphData, startNodeId, callbacks) {
    depthFirstSearchRecursive(graphData, startNodeId, '', initCallbacks$1(callbacks));
  }

  var detectDirectedCycle = function detectDirectedCycle(graphData) {
    var cycle = null;
    var _graphData$nodes = graphData.nodes,
        nodes = _graphData$nodes === void 0 ? [] : _graphData$nodes;
    var dfsParentMap = {}; // 所有没有被访问的节点集合

    var unvisitedSet = {}; // 正在被访问的节点集合

    var visitingSet = {}; // 所有已经被访问过的节点集合

    var visitedSet = {}; // 初始化 unvisitedSet

    nodes.forEach(function (node) {
      unvisitedSet[node.id] = node;
    });
    var callbacks = {
      enter: function enter(_ref) {
        var currentNode = _ref.current,
            previousNode = _ref.previous;

        if (visitingSet[currentNode]) {
          // 如果当前节点正在访问中，则说明检测到环路了
          cycle = {};
          var currentCycleNode = currentNode;
          var previousCycleNode = previousNode;

          while (previousCycleNode !== currentNode) {
            cycle[currentCycleNode] = previousCycleNode;
            currentCycleNode = previousCycleNode;
            previousCycleNode = dfsParentMap[previousCycleNode];
          }

          cycle[currentCycleNode] = previousCycleNode;
        } else {
          // 如果不存在正在访问集合中，则将其放入正在访问集合，并从未访问集合中删除
          visitingSet[currentNode] = currentNode;
          delete unvisitedSet[currentNode]; // 更新 DSF parents 列表

          dfsParentMap[currentNode] = previousNode;
        }
      },
      leave: function leave(_ref2) {
        var currentNode = _ref2.current;
        // 如果所有的节点的子节点都已经访问过了，则从正在访问集合中删除掉，并将其移入到已访问集合中，
        // 同时也意味着当前节点的所有邻居节点都被访问过了
        visitedSet[currentNode] = currentNode;
        delete visitingSet[currentNode];
      },
      allowTraversal: function allowTraversal(_ref3) {
        var nextNode = _ref3.next;

        // 如果检测到环路则需要终止所有进一步的遍历，否则会导致无限循环遍历
        if (cycle) {
          return false;
        } // 仅允许遍历没有访问的节点，visitedSet 中的都已经访问过了


        return !visitedSet[nextNode];
      }
    }; // 开始遍历节点

    while (Object.keys(unvisitedSet).length) {
      // 从第一个节点开始进行 DFS 遍历
      var firsetUnVisitedKey = Object.keys(unvisitedSet)[0];
      depthFirstSearch(graphData, firsetUnVisitedKey, callbacks);
    }

    return cycle;
  };

  var minVertex = function minVertex(D, nodes, marks) {
    // 找出最小的点
    var minDis = Infinity;
    var minNode;

    for (var i = 0; i < nodes.length; i++) {
      var nodeId = nodes[i].id;

      if (!marks[nodeId] && D[nodeId] <= minDis) {
        minDis = D[nodeId];
        minNode = nodes[i];
      }
    }

    return minNode;
  };

  var dijkstra = function dijkstra(graphData, source, directed, weightPropertyName) {
    var _graphData$nodes = graphData.nodes,
        nodes = _graphData$nodes === void 0 ? [] : _graphData$nodes,
        _graphData$edges = graphData.edges,
        edges = _graphData$edges === void 0 ? [] : _graphData$edges;
    var marks = {};
    var D = {};
    var prevs = {}; // key: 顶点, value: 顶点的前驱点数组（可能有多条等长的最短路径）

    nodes.forEach(function (node, i) {
      var id = node.id;
      D[id] = Infinity;
      if (id === source) D[id] = 0;
    });
    var nodeNum = nodes.length;

    var _loop = function _loop(i) {
      // Process the vertices
      var minNode = minVertex(D, nodes, marks);
      var minNodId = minNode.id;
      marks[minNodId] = true;
      if (D[minNodId] === Infinity) return "continue"; // Unreachable vertices cannot be the intermediate point

      var relatedEdges = [];
      if (directed) relatedEdges = getOutEdgesNodeId(minNodId, edges);else relatedEdges = getEdgesByNodeId(minNodId, edges);
      relatedEdges.forEach(function (edge) {
        var edgeTarget = edge.target;
        var edgeSource = edge.source;
        var w = edgeTarget === minNodId ? edgeSource : edgeTarget;
        var weight = weightPropertyName && edge[weightPropertyName] ? edge[weightPropertyName] : 1;

        if (D[w] > D[minNode.id] + weight) {
          D[w] = D[minNode.id] + weight;
          prevs[w] = minNode.id;
        }
      });
    };

    for (var i = 0; i < nodeNum; i++) {
      var _ret = _loop();

      if (_ret === "continue") continue;
    }

    var path = {};

    for (var target in D) {
      path[target] = [target];
      var prev = prevs[target];

      while (prev !== undefined) {
        path[target].unshift(prev);
        prev = prevs[prev];
      }
    }

    return {
      length: D,
      path: path
    };
  };

  var findShortestPath = function findShortestPath(graphData, start, end, directed, weightPropertyName) {
    var _dijkstra = dijkstra(graphData, start, directed, weightPropertyName),
        length = _dijkstra.length,
        path = _dijkstra.path;

    return {
      length: length[end],
      path: path[end]
    };
  };
  var findAllPath = function findAllPath(graphData, start, end, directed) {
    if (start === end) return [[start]];
    var _graphData$edges = graphData.edges,
        edges = _graphData$edges === void 0 ? [] : _graphData$edges;
    var visited = [start];

    var isVisited = _defineProperty({}, start, true);

    var stack = []; // 辅助栈，用于存储访问过的节点的邻居节点

    var allPaths = [];
    var neighbors = directed ? getNeighbors(start, edges, 'target') : getNeighbors(start, edges);
    stack.push(neighbors);

    while (visited.length > 0 && stack.length > 0) {
      var children = stack[stack.length - 1];

      if (children.length) {
        var child = children.shift();

        if (child) {
          visited.push(child);
          isVisited[child] = true;
          neighbors = directed ? getNeighbors(child, edges, 'target') : getNeighbors(child, edges);
          stack.push(neighbors.filter(function (neighbor) {
            return !isVisited[neighbor];
          }));
        }
      } else {
        var node = visited.pop();
        isVisited[node] = false;
        stack.pop();
        continue;
      }

      if (visited[visited.length - 1] === end) {
        var path = visited.map(function (node) {
          return node;
        });
        allPaths.push(path);

        var _node = visited.pop();

        isVisited[_node] = false;
        stack.pop();
      }
    }

    return allPaths;
  };

  var floydWarshall = function floydWarshall(graphData, directed) {
    var adjacentMatrix = adjMatrix(graphData, directed);
    var dist = [];
    var size = adjacentMatrix.length;

    for (var i = 0; i < size; i += 1) {
      dist[i] = [];

      for (var j = 0; j < size; j += 1) {
        if (i === j) {
          dist[i][j] = 0;
        } else if (adjacentMatrix[i][j] === 0 || !adjacentMatrix[i][j]) {
          dist[i][j] = Infinity;
        } else {
          dist[i][j] = adjacentMatrix[i][j];
        }
      }
    } // floyd


    for (var k = 0; k < size; k += 1) {
      for (var _i = 0; _i < size; _i += 1) {
        for (var _j = 0; _j < size; _j += 1) {
          if (dist[_i][_j] > dist[_i][k] + dist[k][_j]) {
            dist[_i][_j] = dist[_i][k] + dist[k][_j];
          }
        }
      }
    }

    return dist;
  };

  /**
   * 标签传播算法
   * @param graphData 图数据
   * @param directed 是否有向图，默认为 false
   * @param weightPropertyName 权重的属性字段
   * @param maxIteration 最大迭代次数
   */

  var labelPropagation = function labelPropagation(graphData) {
    var directed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var weightPropertyName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'weight';
    var maxIteration = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1000;
    // the origin data
    var _graphData$nodes = graphData.nodes,
        nodes = _graphData$nodes === void 0 ? [] : _graphData$nodes,
        _graphData$edges = graphData.edges,
        edges = _graphData$edges === void 0 ? [] : _graphData$edges;
    var clusters = {};
    var nodeMap = {}; // init the clusters and nodeMap

    nodes.forEach(function (node, i) {
      var cid = uniqueId();
      node.clusterId = cid;
      clusters[cid] = {
        id: cid,
        nodes: [node]
      };
      nodeMap[node.id] = {
        node: node,
        idx: i
      };
    }); // the adjacent matrix of calNodes inside clusters

    var adjMatrix$1 = adjMatrix(graphData, directed); // the sum of each row in adjacent matrix
    /**
     * neighbor nodes (id for key and weight for value) for each node
     * neighbors = {
     *  id(node_id): { id(neighbor_1_id): weight(weight of the edge), id(neighbor_2_id): weight(weight of the edge), ... },
     *  ...
     * }
     */

    var neighbors = {};
    adjMatrix$1.forEach(function (row, i) {
      var iid = nodes[i].id;
      neighbors[iid] = {};
      row.forEach(function (entry, j) {
        if (!entry) return;
        var jid = nodes[j].id;
        neighbors[iid][jid] = entry;
      });
    });
    var iter = 0;

    while (iter < maxIteration) {
      var changed = false;
      nodes.forEach(function (node) {
        var neighborClusters = {};
        Object.keys(neighbors[node.id]).forEach(function (neighborId) {
          var neighborWeight = neighbors[node.id][neighborId];
          var neighborNode = nodeMap[neighborId].node;
          var neighborClusterId = neighborNode.clusterId;
          if (!neighborClusters[neighborClusterId]) neighborClusters[neighborClusterId] = 0;
          neighborClusters[neighborClusterId] += neighborWeight;
        }); // find the cluster with max weight

        var maxWeight = -Infinity;
        var bestClusterIds = [];
        Object.keys(neighborClusters).forEach(function (clusterId) {
          if (maxWeight < neighborClusters[clusterId]) {
            maxWeight = neighborClusters[clusterId];
            bestClusterIds = [clusterId];
          } else if (maxWeight === neighborClusters[clusterId]) {
            bestClusterIds.push(clusterId);
          }
        });
        if (bestClusterIds.length === 1 && bestClusterIds[0] === node.clusterId) return;
        var selfClusterIdx = bestClusterIds.indexOf(node.clusterId);
        if (selfClusterIdx >= 0) bestClusterIds.splice(selfClusterIdx, 1);

        if (bestClusterIds && bestClusterIds.length) {
          changed = true; // remove from origin cluster

          var selfCluster = clusters[node.clusterId];
          var nodeInSelfClusterIdx = selfCluster.nodes.indexOf(node);
          selfCluster.nodes.splice(nodeInSelfClusterIdx, 1); // move the node to the best cluster

          var randomIdx = Math.floor(Math.random() * bestClusterIds.length);
          var bestCluster = clusters[bestClusterIds[randomIdx]];
          bestCluster.nodes.push(node);
          node.clusterId = bestCluster.id;
        }
      });
      if (!changed) break;
      iter++;
    } // delete the empty clusters


    Object.keys(clusters).forEach(function (clusterId) {
      var cluster = clusters[clusterId];

      if (!cluster.nodes || !cluster.nodes.length) {
        delete clusters[clusterId];
      }
    }); // get the cluster edges

    var clusterEdges = [];
    var clusterEdgeMap = {};
    edges.forEach(function (edge) {
      var source = edge.source,
          target = edge.target;
      var weight = edge[weightPropertyName] || 1;
      var sourceClusterId = nodeMap[source].node.clusterId;
      var targetClusterId = nodeMap[target].node.clusterId;
      var newEdgeId = "".concat(sourceClusterId, "---").concat(targetClusterId);

      if (clusterEdgeMap[newEdgeId]) {
        clusterEdgeMap[newEdgeId].weight += weight;
        clusterEdgeMap[newEdgeId].count++;
      } else {
        var newEdge = {
          source: sourceClusterId,
          target: targetClusterId,
          weight: weight,
          count: 1
        };
        clusterEdgeMap[newEdgeId] = newEdge;
        clusterEdges.push(newEdge);
      }
    });
    var clustersArray = [];
    Object.keys(clusters).forEach(function (clusterId) {
      clustersArray.push(clusters[clusterId]);
    });
    return {
      clusters: clustersArray,
      clusterEdges: clusterEdges
    };
  };

  var getModularity = function getModularity(nodes, adjMatrix, ks, m) {
    var length = adjMatrix.length;
    var param = 2 * m;
    var modularity = 0;

    for (var i = 0; i < length; i++) {
      var clusteri = nodes[i].clusterId;

      for (var j = 0; j < length; j++) {
        var clusterj = nodes[j].clusterId;
        if (clusteri !== clusterj) continue;
        var entry = adjMatrix[i][j] || 0;
        var ki = ks[i] || 0;
        var kj = ks[j] || 0;
        modularity += entry - ki * kj / param;
      }
    }

    modularity *= 1 / param;
    return modularity;
  };
  /**
   * 社区发现 louvain 算法
   * @param graphData 图数据
   * @param directed 是否有向图，默认为 false
   * @param weightPropertyName 权重的属性字段
   * @param threshold
   */


  var louvain = function louvain(graphData) {
    var directed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var weightPropertyName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'weight';
    var threshold = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.0001;
    // the origin data
    var _graphData$nodes = graphData.nodes,
        nodes = _graphData$nodes === void 0 ? [] : _graphData$nodes,
        _graphData$edges = graphData.edges,
        edges = _graphData$edges === void 0 ? [] : _graphData$edges;
    var clusters = {};
    var nodeMap = {}; // init the clusters and nodeMap

    nodes.forEach(function (node, i) {
      var cid = uniqueId();
      node.clusterId = cid;
      clusters[cid] = {
        id: cid,
        nodes: [node]
      };
      nodeMap[node.id] = {
        node: node,
        idx: i
      };
    }); // the adjacent matrix of calNodes inside clusters

    var adjMatrix$1 = adjMatrix(graphData, directed); // the sum of each row in adjacent matrix

    var ks = [];
    /**
     * neighbor nodes (id for key and weight for value) for each node
     * neighbors = {
     *  id(node_id): { id(neighbor_1_id): weight(weight of the edge), id(neighbor_2_id): weight(weight of the edge), ... },
     *  ...
     * }
     */

    var neighbors = {}; // the sum of the weights of all edges in the graph

    var m = 0;
    adjMatrix$1.forEach(function (row, i) {
      var k = 0;
      var iid = nodes[i].id;
      neighbors[iid] = {};
      row.forEach(function (entry, j) {
        if (!entry) return;
        k += entry;
        var jid = nodes[j].id;
        neighbors[iid][jid] = entry;
        m += entry;
      });
      ks.push(k);
    });
    m /= 2;
    var totalModularity = Infinity;
    var previousModularity = Infinity;
    var iter = 0;

    while (true) {
      // whether to terminate the iterations
      totalModularity = getModularity(nodes, adjMatrix$1, ks, m);
      if (Math.abs(totalModularity - previousModularity) < threshold || iter > 100) break;
      previousModularity = totalModularity;
      iter++; // pre compute some values for current clusters

      Object.keys(clusters).forEach(function (clusterId) {
        // sum of weights of edges to nodes in cluster
        var sumTot = 0;
        edges.forEach(function (edge) {
          var source = edge.source,
              target = edge.target;
          var sourceClusterId = nodeMap[source].node.clusterId;
          var targetClusterId = nodeMap[target].node.clusterId;

          if (sourceClusterId === clusterId && targetClusterId !== clusterId || targetClusterId === clusterId && sourceClusterId !== clusterId) {
            sumTot = sumTot + (edge[weightPropertyName] || 1);
          }
        });
        clusters[clusterId].sumTot = sumTot;
      }); // move the nodes to increase the delta modularity

      nodes.forEach(function (node, i) {
        var selfCluster = clusters[node.clusterId];
        var bestIncrease = 0;
        var bestCluster;
        var commonParam = ks[i] / (2 * m); // sum of weights of edges from node to nodes in cluster

        var kiin = 0;
        var selfClusterNodes = selfCluster.nodes;
        selfClusterNodes.forEach(function (scNode) {
          var scNodeIdx = nodeMap[scNode.id].idx;
          kiin += adjMatrix$1[i][scNodeIdx] || 0;
        }); // the modurarity for **removing** the node i from the origin cluster of node i

        var removeModurarity = kiin - selfCluster.sumTot * commonParam; // the neightbors of the node

        var nodeNeighborIds = neighbors[node.id];
        Object.keys(nodeNeighborIds).forEach(function (neighborNodeId) {
          var neighborNode = nodeMap[neighborNodeId].node;
          var neighborClusterId = neighborNode.clusterId; // if the node and the neighbor of node are in the same cluster, reutrn

          if (neighborClusterId === node.clusterId) return;
          var neighborCluster = clusters[neighborClusterId];
          var clusterNodes = neighborCluster.nodes; // if the cluster is empty, remove the cluster and return

          if (!clusterNodes || !clusterNodes.length) return; // sum of weights of edges from node to nodes in cluster

          var neighborClusterKiin = 0;
          clusterNodes.forEach(function (cNode) {
            var cNodeIdx = nodeMap[cNode.id].idx;
            neighborClusterKiin += adjMatrix$1[i][cNodeIdx] || 0;
          }); // modurarity for **adding** node i into this neighbor cluster

          var addModurarity = neighborClusterKiin - neighborCluster.sumTot * commonParam; // the increase modurarity is the difference between addModurarity and removeModurarity

          var increase = addModurarity - removeModurarity; // find the best cluster to move node i into

          if (increase > bestIncrease) {
            bestIncrease = increase;
            bestCluster = neighborCluster;
          }
        }); // if found a best cluster to move into

        if (bestIncrease > 0) {
          bestCluster.nodes.push(node);
          var previousClusterId = node.clusterId;
          node.clusterId = bestCluster.id; // move the node to the best cluster

          var nodeInSelfClusterIdx = selfCluster.nodes.indexOf(node); // remove from origin cluster

          selfCluster.nodes.splice(nodeInSelfClusterIdx, 1); // update sumTot for clusters
          // sum of weights of edges to nodes in cluster

          var neighborClusterSumTot = 0;
          var selfClusterSumTot = 0;
          edges.forEach(function (edge) {
            var source = edge.source,
                target = edge.target;
            var sourceClusterId = nodeMap[source].node.clusterId;
            var targetClusterId = nodeMap[target].node.clusterId;

            if (sourceClusterId === bestCluster.id && targetClusterId !== bestCluster.id || targetClusterId === bestCluster.id && sourceClusterId !== bestCluster.id) {
              neighborClusterSumTot = neighborClusterSumTot + (edge[weightPropertyName] || 1);
            }

            if (sourceClusterId === previousClusterId && targetClusterId !== previousClusterId || targetClusterId === previousClusterId && sourceClusterId !== previousClusterId) {
              selfClusterSumTot = selfClusterSumTot + (edge[weightPropertyName] || 1);
            }
          }); // the nodes of the clusters to move into and remove are changed, update their sumTot

          bestCluster.sumTot = neighborClusterSumTot;
          selfCluster.sumTot = selfClusterSumTot;
        }
      });
    } // delete the empty clusters


    Object.keys(clusters).forEach(function (clusterId) {
      var cluster = clusters[clusterId];

      if (!cluster.nodes || !cluster.nodes.length) {
        delete clusters[clusterId];
      }
    }); // get the cluster edges

    var clusterEdges = [];
    var clusterEdgeMap = {};
    edges.forEach(function (edge) {
      var source = edge.source,
          target = edge.target;
      var weight = edge[weightPropertyName] || 1;
      var sourceClusterId = nodeMap[source].node.clusterId;
      var targetClusterId = nodeMap[target].node.clusterId;
      var newEdgeId = "".concat(sourceClusterId, "---").concat(targetClusterId);

      if (clusterEdgeMap[newEdgeId]) {
        clusterEdgeMap[newEdgeId].weight += weight;
        clusterEdgeMap[newEdgeId].count++;
      } else {
        var newEdge = {
          source: sourceClusterId,
          target: targetClusterId,
          weight: weight,
          count: 1
        };
        clusterEdgeMap[newEdgeId] = newEdge;
        clusterEdges.push(newEdge);
      }
    });
    var clustersArray = [];
    Object.keys(clusters).forEach(function (clusterId) {
      clustersArray.push(clusters[clusterId]);
    });
    return {
      clusters: clustersArray,
      clusterEdges: clusterEdges
    };
  };

  /**
   * 并查集 Disjoint set to support quick union
   */
  var UnionFind = /*#__PURE__*/function () {
    function UnionFind(items) {
      _classCallCheck(this, UnionFind);

      this.count = items.length;
      this.parent = {};

      var _iterator = _createForOfIteratorHelper(items),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var i = _step.value;
          this.parent[i] = i;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    } // find the root of the item


    _createClass(UnionFind, [{
      key: "find",
      value: function find(item) {
        while (this.parent[item] !== item) {
          item = this.parent[item];
        }

        return item;
      }
    }, {
      key: "union",
      value: function union(a, b) {
        var rootA = this.find(a);
        var rootB = this.find(b);
        if (rootA === rootB) return; // make the element with smaller root the parent

        if (rootA < rootB) {
          if (this.parent[b] !== b) this.union(this.parent[b], a);
          this.parent[b] = this.parent[a];
        } else {
          if (this.parent[a] !== a) this.union(this.parent[a], b);
          this.parent[a] = this.parent[b];
        }
      } // whether a and b are connected, i.e. a and b have the same root

    }, {
      key: "connected",
      value: function connected(a, b) {
        return this.find(a) === this.find(b);
      }
    }]);

    return UnionFind;
  }();

  var defaultCompare = function defaultCompare(a, b) {
    return a - b;
  };

  var MinBinaryHeap = /*#__PURE__*/function () {
    function MinBinaryHeap() {
      var compareFn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultCompare;

      _classCallCheck(this, MinBinaryHeap);

      this.compareFn = compareFn;
      this.list = [];
    }

    _createClass(MinBinaryHeap, [{
      key: "getLeft",
      value: function getLeft(index) {
        return 2 * index + 1;
      }
    }, {
      key: "getRight",
      value: function getRight(index) {
        return 2 * index + 2;
      }
    }, {
      key: "getParent",
      value: function getParent(index) {
        if (index === 0) {
          return null;
        }

        return Math.floor((index - 1) / 2);
      }
    }, {
      key: "isEmpty",
      value: function isEmpty() {
        return this.list.length <= 0;
      }
    }, {
      key: "top",
      value: function top() {
        return this.isEmpty() ? undefined : this.list[0];
      }
    }, {
      key: "delMin",
      value: function delMin() {
        var top = this.top();
        var bottom = this.list.pop();

        if (this.list.length > 0) {
          this.list[0] = bottom;
          this.moveDown(0);
        }

        return top;
      }
    }, {
      key: "insert",
      value: function insert(value) {
        if (value !== null) {
          this.list.push(value);
          var index = this.list.length - 1;
          this.moveUp(index);
          return true;
        }

        return false;
      }
    }, {
      key: "moveUp",
      value: function moveUp(index) {
        var parent = this.getParent(index);

        while (index && index > 0 && this.compareFn(this.list[parent], this.list[index]) > 0) {
          // swap
          var tmp = this.list[parent];
          this.list[parent] = this.list[index];
          this.list[index] = tmp; // [this.list[index], this.list[parent]] = [this.list[parent], this.list[index]]

          index = parent;
          parent = this.getParent(index);
        }
      }
    }, {
      key: "moveDown",
      value: function moveDown(index) {
        var element = index;
        var left = this.getLeft(index);
        var right = this.getRight(index);
        var size = this.list.length;

        if (left !== null && left < size && this.compareFn(this.list[element], this.list[left]) > 0) {
          element = left;
        } else if (right !== null && right < size && this.compareFn(this.list[element], this.list[right]) > 0) {
          element = right;
        }

        if (index !== element) {
          var _ref = [this.list[element], this.list[index]];
          this.list[index] = _ref[0];
          this.list[element] = _ref[1];
          this.moveDown(element);
        }
      }
    }]);

    return MinBinaryHeap;
  }();

  /**
   * Prim algorithm，use priority queue，复杂度 O(E+V*logV), V: 节点数量，E: 边的数量
   * refer: https://en.wikipedia.org/wiki/Prim%27s_algorithm
   * @param graph
   * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致
   */

  var primMST = function primMST(graphData, weight) {
    var selectedEdges = [];
    var _graphData$nodes = graphData.nodes,
        nodes = _graphData$nodes === void 0 ? [] : _graphData$nodes,
        _graphData$edges = graphData.edges,
        edges = _graphData$edges === void 0 ? [] : _graphData$edges;

    if (nodes.length === 0) {
      return selectedEdges;
    } // 从nodes[0]开始


    var currNode = nodes[0];
    var visited = new Set();
    visited.add(currNode); // 用二叉堆维护距已加入节点的其他节点的边的权值

    var compareWeight = function compareWeight(a, b) {
      if (weight) {
        return a.weight - b.weight;
      }

      return 0;
    };

    var edgeQueue = new MinBinaryHeap(compareWeight);
    getEdgesByNodeId(currNode.id, edges).forEach(function (edge) {
      edgeQueue.insert(edge);
    });

    while (!edgeQueue.isEmpty()) {
      // 选取与已加入的结点之间边权最小的结点
      var currEdge = edgeQueue.delMin();
      var source = currEdge.source;
      var target = currEdge.target;
      if (visited.has(source) && visited.has(target)) continue;
      selectedEdges.push(currEdge);

      if (!visited.has(source)) {
        visited.add(source);
        getEdgesByNodeId(source, edges).forEach(function (edge) {
          edgeQueue.insert(edge);
        });
      }

      if (!visited.has(target)) {
        visited.add(target);
        getEdgesByNodeId(target, edges).forEach(function (edge) {
          edgeQueue.insert(edge);
        });
      }
    }

    return selectedEdges;
  };
  /**
   * Kruskal algorithm，复杂度 O(E*logE), E: 边的数量
   * refer: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm
   * @param graph
   * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致
   * @return IEdge[] 返回构成MST的边的数组
   */


  var kruskalMST = function kruskalMST(graphData, weight) {
    var selectedEdges = [];
    var _graphData$nodes2 = graphData.nodes,
        nodes = _graphData$nodes2 === void 0 ? [] : _graphData$nodes2,
        _graphData$edges2 = graphData.edges,
        edges = _graphData$edges2 === void 0 ? [] : _graphData$edges2;

    if (nodes.length === 0) {
      return selectedEdges;
    } // 若指定weight，则将所有的边按权值从小到大排序


    var weightEdges = edges.map(function (edge) {
      return edge;
    });

    if (weight) {
      weightEdges.sort(function (a, b) {
        return a.weight - b.weight;
      });
    }

    var disjointSet = new UnionFind(nodes.map(function (n) {
      return n.id;
    })); // 从权值最小的边开始，如果这条边连接的两个节点于图G中不在同一个连通分量中，则添加这条边
    // 直到遍历完所有点或边

    while (weightEdges.length > 0) {
      var curEdge = weightEdges.shift();
      var source = curEdge.source;
      var target = curEdge.target;

      if (!disjointSet.connected(source, target)) {
        selectedEdges.push(curEdge);
        disjointSet.union(source, target);
      }
    }

    return selectedEdges;
  };
  /**
   * 最小生成树
   * refer: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm
   * @param graph
   * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致
   * @param algo 'prim' | 'kruskal' 算法类型
   * @return EdgeConfig[] 返回构成MST的边的数组
   */


  var minimumSpanningTree = function minimumSpanningTree(graphData, weight, algo) {
    var algos = {
      prim: primMST,
      kruskal: kruskalMST
    };
    if (!algo) return kruskalMST(graphData, weight);
    return algos[algo](graphData, weight);
  };

  /**
   * PageRank https://en.wikipedia.org/wiki/PageRank
   * refer: https://github.com/anvaka/ngraph.pagerank
   * @param graph
   * @param epsilon 判断是否收敛的精度值，默认 0.000001
   * @param linkProb 阻尼系数（dumping factor），指任意时刻，用户访问到某节点后继续访问该节点链接的下一个节点的概率，经验值 0.85
   */

  var pageRank = function pageRank(graphData, epsilon, linkProb) {
    if (typeof epsilon !== 'number') epsilon = 0.000001;
    if (typeof linkProb !== 'number') linkProb = 0.85;
    var distance = 1;
    var leakedRank = 0;
    var maxIterations = 1000;
    var _graphData$nodes = graphData.nodes,
        nodes = _graphData$nodes === void 0 ? [] : _graphData$nodes,
        _graphData$edges = graphData.edges,
        edges = _graphData$edges === void 0 ? [] : _graphData$edges;
    var nodesCount = nodes.length;
    var currentRank;
    var curRanks = {};
    var prevRanks = {}; // Initialize pageranks 初始化

    for (var j = 0; j < nodesCount; ++j) {
      var node = nodes[j];
      var nodeId = node.id;
      curRanks[nodeId] = 1 / nodesCount;
      prevRanks[nodeId] = 1 / nodesCount;
    }

    var nodeDegree = degree(graphData);

    while (maxIterations > 0 && distance > epsilon) {
      leakedRank = 0;

      for (var _j = 0; _j < nodesCount; ++_j) {
        var _node = nodes[_j];
        var _nodeId = _node.id;
        currentRank = 0;

        if (nodeDegree[_node.id].inDegree === 0) {
          curRanks[_nodeId] = 0;
        } else {
          var neighbors = getNeighbors(_nodeId, edges, 'source');

          for (var i = 0; i < neighbors.length; ++i) {
            var neighbor = neighbors[i];
            var outDegree = nodeDegree[neighbor].outDegree;
            if (outDegree > 0) currentRank += prevRanks[neighbor] / outDegree;
          }

          curRanks[_nodeId] = linkProb * currentRank;
          leakedRank += curRanks[_nodeId];
        }
      }

      leakedRank = (1 - leakedRank) / nodesCount;
      distance = 0;

      for (var _j2 = 0; _j2 < nodesCount; ++_j2) {
        var _node2 = nodes[_j2];
        var _nodeId2 = _node2.id;
        currentRank = curRanks[_nodeId2] + leakedRank;
        distance += Math.abs(currentRank - prevRanks[_nodeId2]);
        prevRanks[_nodeId2] = currentRank;
      }

      maxIterations -= 1;
    }

    return prevRanks;
  };

  var Stack = /*#__PURE__*/function () {
    function Stack() {
      var maxStep = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;

      _classCallCheck(this, Stack);

      this.linkedList = new LinkedList();
      this.maxStep = maxStep;
    }

    _createClass(Stack, [{
      key: "isEmpty",

      /**
       * 判断栈是否为空，如果链表中没有头部元素，则栈为空
       */
      value: function isEmpty() {
        return !this.linkedList.head;
      }
      /**
       * 是否到定义的栈的最大长度，如果达到最大长度后，不再允许入栈
       */

    }, {
      key: "isMaxStack",
      value: function isMaxStack() {
        return this.toArray().length >= this.maxStep;
      }
      /**
       * 访问顶端元素
       */

    }, {
      key: "peek",
      value: function peek() {
        if (this.isEmpty()) {
          return null;
        } // 返回头部元素，不删除元素


        return this.linkedList.head.value;
      }
    }, {
      key: "push",
      value: function push(value) {
        this.linkedList.prepend(value);

        if (this.length > this.maxStep) {
          this.linkedList.deleteTail();
        }
      }
    }, {
      key: "pop",
      value: function pop() {
        var removeHead = this.linkedList.deleteHead();
        return removeHead ? removeHead.value : null;
      }
    }, {
      key: "toArray",
      value: function toArray() {
        return this.linkedList.toArray().map(function (node) {
          return node.value;
        });
      }
    }, {
      key: "clear",
      value: function clear() {
        while (!this.isEmpty()) {
          this.pop();
        }
      }
    }, {
      key: "length",
      get: function get() {
        return this.linkedList.toArray().length;
      }
    }]);

    return Stack;
  }();

  exports.Stack = Stack;
  exports.breadthFirstSearch = breadthFirstSearch;
  exports.connectedComponent = getConnectedComponents;
  exports.depthFirstSearch = depthFirstSearch;
  exports.detectCycle = detectDirectedCycle;
  exports.dijkstra = dijkstra;
  exports.findAllPath = findAllPath;
  exports.findShortestPath = findShortestPath;
  exports.floydWarshall = floydWarshall;
  exports.getAdjMatrix = adjMatrix;
  exports.getDegree = degree;
  exports.getInDegree = getInDegree;
  exports.getNeighbors = getNeighbors;
  exports.getOutDegree = getOutDegree;
  exports.labelPropagation = labelPropagation;
  exports.louvain = louvain;
  exports.minimumSpanningTree = minimumSpanningTree;
  exports.pageRank = pageRank;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
