{"version":3,"sources":["../../../src/components/scenegraph/System.ts"],"names":["SceneGraphSystem","IDENTIFIER","HierarchyComponentManager","TransformComponentManager","MeshComponentManager","runTransformUpdateSystem","runHierarchyUpdateSystem","hierarchy","clear","transform","forEach","entity","isDirty","setMeshAABBDirty","updateTransform","parentComponent","transformChild","getComponentByEntity","transformParent","parentID","updateTransformWithParent","parent","isChildAlreadyInLocalSpace","contains","detach","create","getCount","i","parentCandidateEntity","getEntity","j","childCandidateEntity","getComponent","moveItem","parentcomponent","matrixTransform","mat4","invert","worldTransform","applyTransform","removeKeepSorted","mesh","aabbDirty"],"mappings":"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","sourcesContent":["import { mat4 } from 'gl-matrix';\nimport { inject, injectable } from 'inversify';\nimport { Entity } from '../..';\nimport { ComponentManager } from '../../ComponentManager';\nimport { IDENTIFIER } from '../../identifier';\nimport { ISystem } from '../../ISystem';\nimport { MeshComponent } from '../mesh/MeshComponent';\nimport { HierarchyComponent } from './HierarchyComponent';\nimport { TransformComponent } from './TransformComponent';\n\n@injectable()\nexport class SceneGraphSystem implements ISystem {\n  @inject(IDENTIFIER.HierarchyComponentManager)\n  private readonly hierarchy: ComponentManager<HierarchyComponent>;\n\n  @inject(IDENTIFIER.TransformComponentManager)\n  private readonly transform: ComponentManager<TransformComponent>;\n\n  @inject(IDENTIFIER.MeshComponentManager)\n  private readonly mesh: ComponentManager<MeshComponent>;\n\n  public async execute() {\n    this.runTransformUpdateSystem();\n    this.runHierarchyUpdateSystem();\n  }\n\n  public tearDown() {\n    this.hierarchy.clear();\n    this.transform.clear();\n  }\n\n  public getHierarchyComponentManager() {\n    return this.hierarchy;\n  }\n\n  public getTransformComponentManager() {\n    return this.transform;\n  }\n\n  public runTransformUpdateSystem() {\n    // 原版基于 JobSystem 实现\n    this.transform.forEach((entity, transform) => {\n      if (transform.isDirty()) {\n        this.setMeshAABBDirty(entity);\n        transform.updateTransform();\n      }\n    });\n  }\n\n  public runHierarchyUpdateSystem() {\n    this.hierarchy.forEach((entity, parentComponent) => {\n      const transformChild = this.transform.getComponentByEntity(entity);\n      const transformParent = this.transform.getComponentByEntity(\n        parentComponent.parentID,\n      );\n      if (transformChild !== null && transformParent !== null) {\n        transformChild.updateTransformWithParent(transformParent);\n      }\n    });\n  }\n\n  public attach(\n    entity: Entity,\n    parent: Entity,\n    isChildAlreadyInLocalSpace?: boolean,\n  ) {\n    if (this.hierarchy.contains(entity)) {\n      this.detach(entity);\n    }\n\n    this.hierarchy.create(entity, {\n      parentID: parent,\n    });\n\n    // inform parent mesh to update its aabb\n    this.setMeshAABBDirty(parent);\n\n    if (this.hierarchy.getCount() > 1) {\n      for (let i = this.hierarchy.getCount() - 1; i > 0; --i) {\n        const parentCandidateEntity = this.hierarchy.getEntity(i);\n        // const parentCandidateComponent = this.hierarchy.getComponent(i);\n        for (let j = 0; j < i; ++j) {\n          const childCandidateEntity = this.hierarchy.getComponent(j);\n\n          if (childCandidateEntity.parentID === parentCandidateEntity) {\n            this.hierarchy.moveItem(i, j);\n            ++i; // next outer iteration will check the same index again as parent candidate, however things were moved upwards, so it will be a different entity!\n            break;\n          }\n        }\n      }\n    }\n\n    // Re-query parent after potential MoveItem(), because it invalidates references:\n    const parentcomponent = this.hierarchy.getComponentByEntity(entity);\n\n    let transformParent = this.transform.getComponentByEntity(parent);\n    if (transformParent === null) {\n      transformParent = this.transform.create(parent);\n    }\n\n    let transformChild = this.transform.getComponentByEntity(entity);\n    if (transformChild === null) {\n      transformChild = this.transform.create(entity);\n      // after transforms.Create(), transform_parent pointer could have become invalidated!\n      transformParent = this.transform.getComponentByEntity(parent);\n    }\n    if (!isChildAlreadyInLocalSpace && transformParent) {\n      transformChild.matrixTransform(\n        mat4.invert(mat4.create(), transformParent.worldTransform),\n      );\n      transformChild.updateTransform();\n    }\n    if (transformParent) {\n      transformChild.updateTransformWithParent(transformParent);\n    }\n  }\n\n  public detach(entity: Entity) {\n    const parent = this.hierarchy.getComponentByEntity(entity);\n    if (parent !== null) {\n      const transform = this.transform.getComponentByEntity(entity);\n      if (transform !== null) {\n        transform.applyTransform();\n      }\n\n      this.hierarchy.removeKeepSorted(entity);\n\n      // inform parent mesh to update its aabb\n      this.setMeshAABBDirty(entity);\n    }\n  }\n\n  public detachChildren(parent: Entity) {\n    for (let i = 0; i < this.hierarchy.getCount(); ) {\n      if (this.hierarchy.getComponent(i)?.parentID === parent) {\n        const entity = this.hierarchy.getEntity(i);\n        this.detach(entity);\n      } else {\n        ++i;\n      }\n    }\n  }\n\n  private setMeshAABBDirty(entity: Entity) {\n    const mesh = this.mesh.getComponentByEntity(entity);\n    if (mesh) {\n      mesh.aabbDirty = true;\n    }\n  }\n}\n"],"file":"System.js"}